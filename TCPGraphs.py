"""
Created by Egheosa Ogbomo: 24th January 2022
Script for converting tab-delimited text file into Excel and producing plots
Imported modules below
"""
import pandas as pd
import matplotlib.pyplot as plt


Temperatures = ["400K", "500K", "600K"]
Pressures = ["1GPa", "2GPa", "3GPa", "4GPa", "5GPa"]


for T in Temperatures:
    for P in Pressures:
        """
        Plotting graphs showing the total number of intact molecules
        """
        MoleculesIntact = pd.read_csv(
            'F:/PhD/TCPDecompositionExperiments/Completed/FeC/{}/{}/processed/Fe2O3-200-iso-octane_IntactMols_0.3'.format(
                T, P),
            sep='\t')
        """
        Above part of the code uses pandas to open the text file generated by Carlos' script.
        It is important to remember:
        - His code outputs files in 3 File format, so need the '.3' suffix to make sure the file can be read
        - Need the correct path to access the file ofc
        - The sep '\t' is a delimiter that splits up the columns in the generated files so that Python can read it
        - csv can read text files as well as excel files 
        """
        MoleculesIntact.to_excel(
            'F:/PhD/TCPDecompositionExperiments/Completed/FeC/{}/{}/processed/Intact.xlsx'.format(
                T, P),
            'Sheet 1', index=False)
        """
        The above code is what translates from a text file to an excel file:
        - The pathway you include is where the excel file will end up 
        - Molecules is a user chosen name for the imported dataframe that you are now saving to an excel file 
        """
        MI = pd.read_excel(
            'F:/PhD/TCPDecompositionExperiments/Completed/FeC/{}/{}/processed/Intact.xlsx'.format(
                T, P))
        """
        Reading the data from the excel file you you created and setting it to the variable df (can be called whatever, 
        this just seems default) Put it in excel because it's easier to work with than text files in this context 
        """
        MoleculesIntactValue = MI[['Timestep', 'Intact_molecules_omit']]
        """
        The above picks the columns in the excel spreadsheet that you are going to plot
        Have to put the exact column names as they appear in the sheet or will cause an error

        """
        ax = MoleculesIntactValue.plot.line(x='Timestep', y='Intact_molecules_omit')
        plt.savefig(
            'F:/PhD/TCPDecompositionExperiments/Completed/FeC/{}/{}/processed/Intact.png'.format(
                T, P))
        # plt.show() this just displays the plot after it has been created
        # print (MoleculesIntactValue) Can use this to check that you are plotting the correct columns against each other
        """ 
        Plotting graphs showing the total number of each type of bond
        """
        NewMolecules = pd.read_csv(
            'F:/PhD/TCPDecompositionExperiments/Completed/FeC/{}/{}/processed/Fe2O3-200-iso-octane_b0.3'.format(
                T, P), sep='\t')
        """
        Above part of the code uses pandas to open the text file generated by Carlos' script. It is important to remember: 
        - His code outputs files in 3 File format, so need the '.3' suffix to make sure the file can be read - Need the 
        correct path to access the file ofc 
        - The sep '\t' is a delimiter that splits up the columns in the generated files 
        so that Python can read it 
        - csv can read text files as well as excel files - Setting the value = to NewMolecules in 
        this case but set name to something unique and relevant depending on file you are processing 
        """
        NewMolecules.to_excel(
            'F:/PhD/TCPDecompositionExperiments/Completed/FeC/{}/{}/processed/NewMolecules.xlsx'.format(
                T, P),
            'Sheet 1', index=False)
        """
        The above code is what translates from a text file to an excel file:
        - The pathway you include is where the excel file will end up 
        - MoleculesIntact is a user chosen name for the imported dataframe that you are now saving to an excel file 
        """
        NM = pd.read_excel(
            'F:/PhD/TCPDecompositionExperiments/Completed/FeC/{}/{}/processed/NewMolecules.xlsx'.format(
                T, P))
        """
        Reading the data from the excel file you you created and setting it to the variable df (can be called whatever, this 
        just seems default)
        Put it in excel because it's easier to work with than text files in this context 
        """
        head = NM.columns
        header = head[:-1]

        # print(header)
        '''
        The lines above are to get a list of the headings from the bondtypes in the experiment
        and trim the last column, which doesn't have useful info in this case
        '''
        Carbon_Carbon_Bonds_List = []
        Carbon_Phosphorous_Bonds = []
        Oxygen_Oxygen_Bonds = []
        Iron_Oxygen_Bonds = []
        Carbon_Hydrogen_Bonds = []
        Carbon_Oxygen_Bonds = []
        Hydrogen_Hydrogen_Bonds = []
        Iron_Phosphorous = []
        Iron_Iron_Bonds = []
        Iron_Hydrogen_Bonds = []
        Hydrogen_Oxygen_Bonds = []
        Oxygen_Phosphorous_Bonds = []
        Carbon_Iron_Bonds = []
        Phosphorous_Phosphorous = []
        Hydrogen_Phosphorous = []
        '''
        Above is to define empty lists for retrieving individual bonds types from the bond type 
        dataframe. Must keep it out of the for loop to stop the for loop emptying it in every
        iteration. 
        '''
        for bond in header:
            if bond.count('C') == 2:
                Carbon_Carbon_Bonds_List.append(bond)
            elif bond.count('P') == 2:
                Phosphorous_Phosphorous.append(bond)
            elif bond.count('H') == 2:
                Hydrogen_Hydrogen_Bonds.append(bond)
            elif bond.count('O') == 2:
                Oxygen_Oxygen_Bonds.append(bond)
            elif bond.count('Fe') == 2:
                Iron_Iron_Bonds.append(bond)
            # Have to put the statements for like bonds at the beginning or else you might have some of these bonds in the wrong
            # list, which you don't want
            elif bond.count('C') + bond.count('P') == 2:
                Carbon_Phosphorous_Bonds.append(bond)
            elif bond.count('Fe') + bond.count('H') == 2:
                Iron_Hydrogen_Bonds.append(bond)
            elif bond.count('H') + bond.count('C') == 2:
                Carbon_Hydrogen_Bonds.append(bond)
            elif bond.count('Fe') + bond.count('C') == 2:
                Carbon_Iron_Bonds.append(bond)
            elif bond.count('H') + bond.count('O') == 2:
                Hydrogen_Oxygen_Bonds.append(bond)
            elif bond.count('H') + bond.count('P') == 2:
                Hydrogen_Phosphorous.append(bond)
            elif bond.count('Fe') + bond.count('O') == 2:
                Iron_Oxygen_Bonds.append(bond)
            elif bond.count('Fe') + bond.count('P') == 2:
                Iron_Phosphorous.append(bond)
            elif bond.count('O') + bond.count('P') == 2:
                Oxygen_Phosphorous_Bonds.append(bond)
            elif bond.count('O') + bond.count('C') == 2:
                Carbon_Oxygen_Bonds.append(bond)
            else:
                print(bond)  # identifies any bonds that you aren't appending to a list so that none are missed.

        '''
        Above is one massive for-if-elif block which goes through the list of bond types by ID (which has been
        saved into the variable 'header', each bond ID (using the for bond in header) (e.g. C1-C1 or C1-C2) is then evaluated 
        to determine what bond it's showing (e.g. C1-C2 shows a Carbon Carbon bond, while O1-P1 shows Oxygen-Phosphorous 
        bonding). Then the if-elif sorts each bond type to its corresponding list, meaning we can then sum the total of each 
        bond type below. 
        '''

        NM['Total CC'] = NM[Carbon_Carbon_Bonds_List].sum(axis=1)
        NM['Total CO'] = NM[Carbon_Oxygen_Bonds].sum(axis=1)
        NM['Total CP'] = NM[Carbon_Phosphorous_Bonds].sum(axis=1)
        NM['Total OO'] = NM[Oxygen_Oxygen_Bonds].sum(axis=1)
        NM['Total FeO'] = NM[Iron_Oxygen_Bonds].sum(axis=1)
        NM['Total CH'] = NM[Carbon_Hydrogen_Bonds].sum(axis=1)
        NM['Total CFe'] = NM[Carbon_Iron_Bonds].sum(axis=1)
        NM['Total PO'] = NM[Oxygen_Phosphorous_Bonds].sum(axis=1)
        NM['Total HH'] = NM[Hydrogen_Hydrogen_Bonds].sum(axis=1)
        NM['Total HO'] = NM[Hydrogen_Oxygen_Bonds].sum(axis=1)
        NM['Total FeH'] = NM[Iron_Hydrogen_Bonds].sum(axis=1)
        NM['Total PP'] = NM[Phosphorous_Phosphorous].sum(axis=1)
        NM['Total HP'] = NM[Hydrogen_Phosphorous].sum(axis=1)
        NM['Total FeFe'] = NM[Iron_Iron_Bonds].sum(axis=1)
        NM['Total FeP'] = NM[Iron_Phosphorous].sum(axis=1)

        # print(MoleculesIntactList)
        # print(NM['O_1-P_1'])
        # print(NM['C_5-O_1'])
        # print(NM['Total PO'])
        # print(NM['Total CO'])
        '''
        Using the generated header lists from above, making new dataframes by selecting titles from the big dataframe with 
        all the bond types 
        '''

        # import seaborn as sns
        CO_vs_PO = NM[['Timestep', 'Total CO', 'Total PO']]
        # print(CO_vs_PO)
        # CO_vs_PO.plot.line()
        Timestep_List = CO_vs_PO['Timestep'].to_list()
        Total_CO_List = NM['C_5-O_1'].to_list()
        Total_PO_List = NM['Total PO'].to_list()

        Modified_Total_PO_List = []
        Modified_Total_CO_List = []
        for x in range(len(Total_PO_List)):
            Modified_Total_PO_List.append(Total_PO_List[x] - Total_PO_List[0])
        for x in range(len(Total_PO_List)):
            Modified_Total_CO_List.append(Total_CO_List[x] - Total_CO_List[0])
        """
        The above line just prints NM to make sure that we are getting all of the output from the generated 
        excel file, and that it is in the right (tab-delimited) format
        """
        NumberofBondTypes = len(NM.columns)
        """
        Here we extract the number of columns with data in them, each column has data on a different bond type, 
        apart from the first column which corresponds to the 
        """
        # print(NumberofBondTypes)
        """
        Making sure that the function above for getting the number of columns with data in them actually works
        """
        Time = []
        for x in Timestep_List:
            Time.append(((x - 400000) / int(4 * 10 ** 6)))

        NM.insert(0, 'Time', Time, True)
        # print(NM)
        """
        The above line just prints NM to make sure that we are getting all of the output from the generated 
        excel file, and that it is in the right (tab-delimited) format
        """
        NumberofBondTypes = len(NM.columns)


        """
        - Create a variable (in this case called 'Index') and set it equal to one to represent the first column from the created
        - While loop then cycles through by creating a variable named BOND that is a string of two columns with the first column
        being the Timestep column from the spreadsheet and the second being a column with the number of BONDS, the column being
        selected depending on how many iterations have been completed (you add one to the value of 'Index' after every iteration
        - You've set the loop to run until 1 less than the total number of columns in the spreadsheet which you've calculated
        using the variable 'NumberofBondTypes'
        - Use the plot.line (from matplotlib) to plot the two called columns, set x= to 'Timestep' otherwise it will use
        - You used the BOND.columns module to get the headings of the two columns that you called from the excel spreadsheet
        the BONDTYPENAME[-1] function to call only the last column name of the two, which will correspond to the name of the
        bonds you are looking at in this iteration of the while loop, which in turn you can set as a variable (in this case
        'GRAPHNAME' to automatically name each graph you plot
        """
        #excel spreadsheet that you'll reference in the while loop using the 'iloc' (from pandas) module

        CODataframe = NM[['C_5-O_1']]
        PODataframe = NM[['O_1-P_1']]

        # print(CODataframe)
        # print(PODataframe)

        TotalPOBond1DList = []
        TotalCOBond1DList = []
        C5O1BondsList = []
        POSingleBonds1DList = []

        TotalPOBond1DList.append(list(NM['Total PO']))
        TotalCOBond1DList.append(list(NM['C_5-O_1']))
        C5O1BondsList.append(list(NM['C_5-O_1']))
        POSingleBonds1DList.append(list(NM['O_1-P_1']))

        C5O1BondsBroken = [0]
        C5O1BondsFormed = [0]
        POSingleBondsBroken = [0]
        POSingleBondsFormed = [0]
        TotalPOBrokenBonds = [0]
        TotalPOFormedBonds = [0]
        TotalCOFormedBonds = [0]
        TotalCOBrokenBonds = [0]

        for eachlist in TotalPOBond1DList:
            # print(len(eachlist))
            index = 1
            sumbroken = 0
            sumformed = 0
            for x in eachlist:
                while index < len(eachlist):
                    a = eachlist[index]
                    b = eachlist[index - 1]
                    if a - b > 0:
                        sumformed += (a - b)
                        TotalPOFormedBonds.append(sumformed)
                        TotalPOBrokenBonds.append(sumbroken)
                    elif a - b < 0:
                        sumbroken += (a - b)
                        TotalPOBrokenBonds.append(sumbroken)
                        TotalPOFormedBonds.append(sumformed)
                    else:
                        TotalPOFormedBonds.append(sumformed)
                        TotalPOBrokenBonds.append(sumbroken)
                    index += 1

        for eachlist in TotalCOBond1DList:
            # print(eachlist)
            index = 1
            sumbroken = 0
            sumformed = 0
            for x in eachlist:
                while index < len(eachlist):
                    a = eachlist[index]
                    b = eachlist[index - 1]
                    if a - b > 0:
                        sumformed += (a - b)
                        TotalCOFormedBonds.append(sumformed)
                        TotalCOBrokenBonds.append(sumbroken)
                    elif a - b < 0:
                        sumbroken += (a - b)
                        TotalCOBrokenBonds.append(sumbroken)
                        TotalCOFormedBonds.append(sumformed)
                    else:
                        TotalCOFormedBonds.append(sumformed)
                        TotalCOBrokenBonds.append(sumbroken)
                    index += 1

        for eachlist in POSingleBonds1DList:
            # print(eachlist)
            index = 1
            POsumbroken = 0
            POsumformed = 0
            for x in eachlist:
                while index < len(eachlist):
                    a = eachlist[index]
                    b = eachlist[index - 1]
                    if a - b > 0:
                        POsumformed += (a - b)
                        POSingleBondsFormed.append(POsumformed)
                        POSingleBondsBroken.append(POsumbroken)
                    elif a - b < 0:
                        POsumbroken += (a - b)
                        POSingleBondsBroken.append(POsumbroken)
                        POSingleBondsFormed.append(POsumformed)
                    else:
                        POSingleBondsFormed.append(POsumformed)
                        POSingleBondsBroken.append(POsumbroken)
                    index += 1

        for eachlist in C5O1BondsList:
            # print(eachlist)
            index = 1
            C5sumbroken = 0
            C5sumformed = 0
            for x in eachlist:
                while index < len(eachlist):
                    a = eachlist[index]
                    b = eachlist[index - 1]
                    if a - b > 0:
                        C5sumformed += (a - b)
                        C5O1BondsFormed.append(C5sumformed)
                        C5O1BondsBroken.append(C5sumbroken)
                    elif a - b < 0:
                        C5sumbroken += (a - b)
                        C5O1BondsBroken.append(C5sumbroken)
                        C5O1BondsFormed.append(C5sumformed)
                    else:
                        C5O1BondsFormed.append(C5sumformed)
                        C5O1BondsBroken.append(C5sumbroken)
                    index += 1

        # print(len(Timestep_List))
        # print(TotalPOBrokenBonds)
        # print(len(TotalPOBrokenBonds))
        # print(TotalPOFormedBonds)
        # print(len(TotalPOFormedBonds))
        #
        # print(C5O1BondsBroken)
        # print(len(C5O1BondsBroken))
        # print(C5O1BondsFormed)
        # print(len(C5O1BondsFormed))

        Time = []
        for x in Timestep_List:
            Time.append(((x - 400000) / int(4 * 10 ** 6)))

        fig2, ax2 = plt.subplots()
        ax2.plot(Time, Modified_Total_CO_List, label='C-O')
        ax2.plot(Time, Modified_Total_PO_List, label='P-O')
        ax2.plot(Time, POSingleBondsBroken, label='P-O Broken Bonds', linestyle='dashed')
        ax2.plot(Time, POSingleBondsFormed, label='P-O Formed Bonds', linestyle='dashed')
        ax2.plot(Time, C5O1BondsBroken, label='C5-O1 Broken Bonds', linestyle='dashed')
        ax2.plot(Time, C5O1BondsFormed, label='C5-O1 Formed Bonds', linestyle='dashed')
        ax2.legend()
        ax2.set_xlabel('Time (ns)')
        ax2.set_ylabel('Change in Number of Bonds')
        ax2.set_title('P-O Bonds vs C-O Bonds')
        fig2.savefig(
            'F:/PhD/TCPDecompositionExperiments/Completed/FeC/{}/{}/processed/Important_PO_vs_CO.png'.format(
                T, P))

